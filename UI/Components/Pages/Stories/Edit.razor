@page "/stories/edit/{Id:int}"
@rendermode InteractiveServer

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Components
@using System.Net
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.EntityFrameworkCore
@using mass.Data
@using mass.Components.Shared

@attribute [Authorize]

@inject MassDbContext DbContext
@inject UserManager<MassIdentityUser> UserManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject ILogger<Edit> Logger

<PageTitle>@(Loading ? "Edit Story" : $"Editing: {StoryEntity?.Title}")</PageTitle>

<div class="d-flex justify-content-between align-items-center mb-3">
    <h1>@(Loading ? "Edit Story" : $"Editing: {StoryEntity?.Title}")</h1>
    @if (!Loading && !NotFound && Authorized)
    {
        <a href="/stories/read/@Id" class="btn btn-info">Read This Story Now</a>
    }
</div>

<ToastContainer @ref="toastContainer" />

@if (Loading)
{
    <p><em>Loading...</em></p>
}
else if (NotFound)
{
    <div class="alert alert-danger">Story not found.</div>
}
else if (!Authorized)
{
    <div class="alert alert-danger">You are not authorized to edit this story.</div>
}
else
{
    @if (IsLocked && !IsLockedByCurrentUser)
    {
        <div class="alert alert-warning">
            <strong>Warning:</strong> This story is currently locked for editing by <strong>@IsLockedByUserName</strong>. 
            You will need to wait until they have finished editing before you can make changes.

            @if (IsCreator)
            {
                <p class="mt-2">
                    As the creator of this story, you can
                    <button type="button" @onclick="() => {
                        StoryEntity!.IsLocked = false;
                        StoryEntity.LockedBy = null;
                        DbContext.SaveChanges();
                        IsLocked = false;
                    }" class="btn btn-link p-0">Override The Lock</button>
                    if necessary.
                </p>
            }
        </div>
    } else if (IsLocked && (IsLockedByCurrentUser || IsCreator)) {
        <div class="alert alert-success">
            <p>You have locked this story for editing.  Other users will not be able to make changes until you have finished.</p>
            <button class="btn btn-warning" @onclick="() => {
                StoryEntity!.IsLocked = false;
                StoryEntity.LockedBy = null;
                DbContext.SaveChanges();
                IsLocked = false;
            }">Unlock Story</button>
        </div>
    } else {
        <div class="alert alert-info">
            <p>This story is not currently locked.  To prevent editing conflicts, you can lock the story for your use while you make changes.</p>
            <button class="btn btn-primary" @onclick="() => {
                StoryEntity!.IsLocked = true;
                StoryEntity.LockedBy = CurrentUser!;
                DbContext.SaveChanges();
                IsLocked = true;
            }">Lock Story for Editing</button>
        </div>
    }
    <div class="accordion mb-4" id="editAccordion">
        <div class="accordion-item">
            <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#editForm" aria-expanded="false" aria-controls="editForm">
                    Edit Story Details
                </button>
            </h2>
            <div id="editForm" class="accordion-collapse collapse" data-bs-parent="#editAccordion">
                <div class="accordion-body">
                    <EditForm Model="Input" OnValidSubmit="Save" method="post" FormName="edit-story">
                        <DataAnnotationsValidator />
                        <ValidationSummary class="text-danger" />

                        <div class="form-floating mb-3">
                            <InputText @bind-Value="Input!.Title" id="Input.Title" class="form-control" placeholder="Story title" />
                            <label for="Input.Title">Title</label>
                            <ValidationMessage For="() => Input.Title" class="text-danger" />
                        </div>

                        <div class="form-floating mb-3">
                            <InputTextArea @bind-Value="Input.Description" id="Input.Description" class="form-control" placeholder="Short description" rows="4" />
                            <label for="Input.Description">Description</label>
                            <ValidationMessage For="() => Input.Description" class="text-danger" />
                        </div>

                        <div class="mb-3">
                            <div class="form-check form-switch">
                                <InputCheckbox class="form-check-input" @bind-Value="Input.IsPublic" id="Input.IsPublic" />
                                <label class="form-check-label" for="Input.IsPublic">Public</label>
                            </div>
                            <ValidationMessage For="() => Input.IsPublic" class="text-danger" />
                        </div>
                        @if (IsCreator)
                        {
                            <div class="mb-3">
                                <div class="form-check form-switch">
                                    <InputCheckbox class="form-check-input" @bind-Value="Input.IsArchived" id="Input.IsArchived" />
                                    <label class="form-check-label" for="Input.IsArchived">Archived</label>
                                </div>
                                <ValidationMessage For="() => Input.IsArchived" class="text-danger" />
                            </div>
                        }
                        <button type="submit" class="btn btn-primary" disabled="@Saving">
                        @if (Saving)
                        {
                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true">Savingâ€¦</span> 
                        }
                        else
                        {
                            <span>Save</span>
                        }
                        </button>
                        <button type="button" class="btn btn-secondary" @onclick="Cancel">Cancel</button>
                    </EditForm>
                </div>
            </div>
        </div>
    </div>
}


@* Add entry / New chapter forms *@
@if (!Loading && !NotFound && Authorized && CurrentUserShouldBeAbleToEdit)
{
    <div class="row">
        <div class="col-md-6">
            <h3>Add to Last Chapterz: @(StoryEntity?.Chapters?.OrderByDescending(c => c.Order).FirstOrDefault()?.Title ?? "No chapters yet")</h3>
            <EditForm Model="AddEntryInput" OnSubmit="HandleAddEntrySubmit" FormName="add-entry" class="mb-3">
                <DataAnnotationsValidator />
                <ValidationSummary class="text-danger" />

                <div class="mb-3">
                    <label for="addEntryContent" class="form-label">Entry</label>
                    <QuillEditor @ref="addEntryEditor" Content="@(AddEntryInput?.Content ?? "")" ContentChanged="@((content) => { if (AddEntryInput != null) AddEntryInput.Content = content; })" Placeholder="Write your entry here..." />
                </div>

                <button type="submit" class="btn btn-primary" disabled="@(Adding)">Add to last chapter</button>
            </EditForm>
        </div>

        <div class="col-md-6">
            <h3>Start New Chapter</h3>
            <EditForm Model="NewChapterInput" OnValidSubmit="StartNewChapter" FormName="new-chapter">
                <DataAnnotationsValidator />
                <ValidationSummary class="text-danger" />

                <div class="mb-3">
                    <label for="newChapterTitle" class="form-label">Chapter Title</label>
                    <InputText @bind-Value="NewChapterInput.Title" id="newChapterTitle" class="form-control" />
                </div>

                <button type="submit" class="btn btn-secondary" disabled="@(Adding)">Create Chapter</button>
            </EditForm>
        </div>
    </div>
}


@* Chapters & Entries (read-only) *@
@if (!Loading && !NotFound && Authorized && StoryEntity?.Chapters?.Any() == true)
{
    <hr />
    <h2>Chapters</h2>

<div class="accordion" id="chaptersAccordion">
    @foreach (var chapter in StoryEntity.Chapters.OrderBy(c => c.Order))
    {
        <div class="accordion-item">
            <h2 class="accordion-header" id="@(chapter.Id + "headingOne")">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#@(chapter.Id + "collapse")" aria-expanded="true" aria-controls="collapseOne" style="@(ChapterHasNewEntries(chapter) ? "background-color: #e2f5ef; color: inherit;" : "")">
                @chapter.Order - @chapter.Title
            </button>
            </h2>
            <div id="@(chapter.Id + "collapse")" class="accordion-collapse collapse" aria-labelledby="@(chapter.Id + "headingOne")">
                <div class="accordion-body">
                    @if (chapter.Entries?.Any() == true)
                    {
                        @foreach (var entry in chapter.Entries.OrderBy(e => e.Order))
                        {
                            <div class="mb-3">
                                <div class="small text-muted d-flex align-items-center gap-2">
                                    <span>By @entry.CreatedBy?.UserName on @entry.CreatedAt.ToLocalTime().ToString("g")</span>
                                    @if (EntryIsNew(entry))
                                    {
                                        <span class="badge bg-success">New!</span>
                                    }
                                </div>
                                @if (EditingEntryId == entry.Id)
                                {
                                    <QuillEditor @ref="editEntryEditor" Content="@(EditingEntryContent ?? "")" ContentChanged="@((content) => EditingEntryContent = content)" Placeholder="Edit your entry..." />
                                    <div class="mt-2">
                                        <button class="btn btn-sm btn-primary" @onclick="() => SaveEntryEdit(entry)">Save</button>
                                        <button class="btn btn-sm btn-secondary" @onclick="CancelEntryEdit">Cancel</button>
                                    </div>
                                }
                                else
                                {
                                    <p class="p-3 bg-light border rounded">@FormatContent(entry.Content)</p>
                                    @if (CurrentUser?.Id == entry.CreatedBy?.Id)
                                    {
                                        <button class="btn btn-sm btn-secondary" disabled=@(!CurrentUserShouldBeAbleToEdit) @onclick="() => StartEditEntry(entry)">Edit</button>
                                    }
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div class="text-muted">No entries yet.</div>
                    }
                </div>
            </div>
        </div>        
    }
</div>
}



@code {
    [Parameter]
    public int Id { get; set; }

    private Story? StoryEntity;
    private MassIdentityUser? CurrentUser;
    private bool Loading = true;
    private bool NotFound = false;
    private bool Authorized = false;
    private bool IsCreator = false;
    private bool IsLocked = false;
    private bool IsLockedByCurrentUser => CurrentUser != null && StoryEntity?.LockedBy != null && CurrentUser.Id == StoryEntity.LockedBy.Id;
    private string IsLockedByUserName = "";
    private bool CurrentUserShouldBeAbleToEdit => Authorized && (!IsLocked || IsLockedByCurrentUser || IsCreator);
    private int? EditingEntryId;
    private string? EditingEntryContent;
    private ToastContainer? toastContainer;
    private QuillEditor? addEntryEditor;
    private QuillEditor? editEntryEditor;

    [SupplyParameterFromForm(FormName = "edit-story")]
    private InputModel? Input { get; set; }

    private async Task ShowToast(string message)
    {
        if (toastContainer != null)
        {
            await toastContainer.ShowToast(message);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = await UserManager.GetUserAsync(authState.User);

        if (user is null)
        {
            await ShowToast("Error: unable to load current user.");
            Loading = false;
            return;
        }

        CurrentUser = user;

        try
        {
            StoryEntity = await DbContext.Stories
                .Include(s => s.CreatedBy)
                .Include(s => s.Contributors)
                .Include(s => s.Chapters).ThenInclude(c => c.Entries).ThenInclude(e => e.CreatedBy)
                .SingleOrDefaultAsync(s => s.Id == Id);

            if (StoryEntity is null)
            {
                NotFound = true;
                return;
            }

            var userId = user.Id;
            Authorized = StoryEntity.CreatedBy.Id == userId || StoryEntity.Contributors.Any(c => c.Id == userId);
            IsCreator = StoryEntity.CreatedBy.Id == userId;

            if (!Authorized)
            {
                return;
            }

            IsLocked = StoryEntity.IsLocked;
            if (IsLocked && StoryEntity.LockedBy != null)
            {
                IsLockedByUserName = StoryEntity.LockedBy.UserName ?? "";
            }

            if (Input is null)
            {
                Input = new InputModel();
                Input.Title ??= StoryEntity.Title;
                Input.Description ??= StoryEntity.Description;
                Input.IsPublic = StoryEntity.IsPublic;
                Input.IsArchived = StoryEntity.IsArchived;
            }

            if (AddEntryInput is null)
            {
                AddEntryInput = new AddEntryModel();
            }

            if (NewChapterInput is null)
            {
                NewChapterInput = new NewChapterModel();
            }

        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading story {StoryId}", Id);
            await ShowToast("Error loading story.");
        }
        finally
        {
            Loading = false;
        }
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(200, MinimumLength = 1)]
        public string? Title { get; set; }

        [Required]
        [StringLength(2000, MinimumLength = 1)]
        public string? Description { get; set; }

        public bool IsPublic { get; set; }
        public bool IsArchived { get; set; }
    }

    private bool Adding = false;
    private bool Saving = false;

    private async Task Save(EditContext context)
    {
        Saving = true;
        try {
            if (StoryEntity is null)
            {
                await ShowToast("Error: story not loaded.");
                return;
            }

            if (Input is null || string.IsNullOrEmpty(Input.Title) || string.IsNullOrEmpty(Input.Description))
            {
                await ShowToast("Error: invalid input.");
                return;
            }

            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);

            if (user is null)
            {
                await ShowToast("Error: unable to load current user.");
                return;
            }

            var userId = user.Id;
            var isAuthorized = StoryEntity.CreatedBy.Id == userId || StoryEntity.Contributors.Any(c => c.Id == userId);

            if (!isAuthorized)
            {
                await ShowToast("Error: you are not authorized to edit this story.");
                return;
            }

            try
            {
                StoryEntity.Title = Input!.Title!;
                StoryEntity.Description = Input!.Description!;
                StoryEntity.IsPublic = Input.IsPublic;
                StoryEntity.IsArchived = Input.IsArchived;
                StoryEntity.LastModifiedAt = DateTime.UtcNow;

                await DbContext.SaveChangesAsync();

                await ShowToast("Story saved successfully.");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error saving story {StoryId}", Id);
                await ShowToast("Error saving story.");
            }
        } finally {
            Saving = false;
        }
    }

    [SupplyParameterFromForm(FormName = "add-entry")]
    private AddEntryModel? AddEntryInput { get; set; }
    
    [SupplyParameterFromForm(FormName = "new-chapter")]
    private NewChapterModel? NewChapterInput { get; set; }

    private sealed class AddEntryModel
    {
        [Required]
        [StringLength(10000, MinimumLength = 1)]
        public string? Content { get; set; }
    }

    private sealed class NewChapterModel
    {
        [Required]
        [StringLength(200, MinimumLength = 1)]
        public string? Title { get; set; }
    }

    private async Task AddToLastChapter(EditContext _)
    {
        if (StoryEntity is null)
        {
            await ShowToast("Error: story not loaded.");
            return;
        }

        if (AddEntryInput is null)
        {
            await ShowToast("Error: entry input not initialized.");
            return;
        }

        Adding = true;
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);

            if (user is null)
            {
                await ShowToast("Error: unable to load current user.");
                return;
            }

            var lastChapter = StoryEntity.Chapters.OrderByDescending(c => c.Order).FirstOrDefault();

            if (lastChapter is null)
            {
                // create first chapter
                var chapter = new Chapter
                {
                    Story = StoryEntity,
                    CreatedBy = user,
                    Title = "Chapter 1",
                    Order = 1
                };

                var entry = new Entry
                {
                    Chapter = chapter,
                    CreatedBy = user,
                    Content = AddEntryInput.Content ?? string.Empty,
                    Order = 1
                };

                chapter.Entries.Add(entry);
                StoryEntity.Chapters.Add(chapter);
                DbContext.Add(chapter);
            }
            else
            {
                var nextEntryOrder = (lastChapter.Entries?.Any() == true) ? lastChapter.Entries.Max(e => e.Order) + 1 : 1;
                var entry = new Entry
                {
                    Chapter = lastChapter,
                    CreatedBy = user,
                    Content = AddEntryInput.Content ?? string.Empty,
                    Order = nextEntryOrder
                };

                lastChapter.Entries!.Add(entry);
                DbContext.Add(entry);
            }

            StoryEntity.LastModifiedAt = DateTime.UtcNow;
            await DbContext.SaveChangesAsync();

            // clear input and show updated UI
            AddEntryInput = new AddEntryModel();
            await ShowToast("Entry added.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding entry to story {StoryId}", Id);
            await ShowToast("Error adding entry.");
        }
        finally
        {
            Adding = false;
        }
    }

    private async Task StartNewChapter(EditContext _)
    {
        if (StoryEntity is null)
        {
            await ShowToast("Error: story not loaded.");
            return;
        }

        if (NewChapterInput is null)
        {
            await ShowToast("Error: chapter input not initialized.");
            return;
        }

        Adding = true;
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = await UserManager.GetUserAsync(authState.User);

            if (user is null)
            {
                await ShowToast("Error: unable to load current user.");
                return;
            }

            var nextChapterOrder = (StoryEntity.Chapters?.Any() == true) ? StoryEntity.Chapters.Max(c => c.Order) + 1 : 1;

            var chapter = new Chapter
            {
                Story = StoryEntity,
                CreatedBy = user,
                Title = NewChapterInput.Title ?? $"Chapter {nextChapterOrder}",
                Order = nextChapterOrder
            };

            StoryEntity.Chapters!.Add(chapter);
            DbContext.Add(chapter);

            StoryEntity.LastModifiedAt = DateTime.UtcNow;
            await DbContext.SaveChangesAsync();

            NewChapterInput = new NewChapterModel();
            await ShowToast("Chapter created successfully.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating chapter for story {StoryId}", Id);
            await ShowToast("Error creating chapter.");
        }
        finally
        {
            Adding = false;
        }
    }

    private static MarkupString FormatContent(string? content)
    {
        // Content from Quill is already HTML, so just return it as-is
        // Quill handles content sanitization, so it's safe to render directly
        return (MarkupString)(content ?? "");
    }

    private DateTimeOffset? GetCurrentUserLastEntryTime()
    {
        if (CurrentUser is null || StoryEntity?.Chapters is null)
            return null;

        return StoryEntity.Chapters
            .SelectMany(c => c.Entries)
            .Where(e => e.CreatedBy.Id == CurrentUser.Id)
            .Max(e => (DateTimeOffset?)e.CreatedAt);
    }

    private bool ChapterHasNewEntries(Chapter chapter)
    {
        if (CurrentUser is null)
            return false;

        var currentUserLastEntry = GetCurrentUserLastEntryTime();
        if (currentUserLastEntry is null)
            return false;

        return chapter.Entries?.Any(e => 
            e.CreatedBy.Id != CurrentUser.Id && 
            e.CreatedAt > currentUserLastEntry) ?? false;
    }

    private bool EntryIsNew(Entry entry)
    {
        if (CurrentUser is null)
            return false;

        var currentUserLastEntry = GetCurrentUserLastEntryTime();
        if (currentUserLastEntry is null)
            return false;

        return entry.CreatedBy.Id != CurrentUser.Id && entry.CreatedAt > currentUserLastEntry;
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/stories");
    }

    private async Task HandleAddEntrySubmit(EditContext context)
    {
        // Capture content from Quill editor before validation
        if (addEntryEditor != null && AddEntryInput != null)
        {
            AddEntryInput.Content = await addEntryEditor.GetContent();
        }

        // Now validate and submit
        if (context.Validate())
        {
            await AddToLastChapter(context);
        }
    }

    private void StartEditEntry(Entry entry)
    {
        EditingEntryId = entry.Id;
        EditingEntryContent = entry.Content;
    }

    private void CancelEntryEdit()
    {
        EditingEntryId = null;
        EditingEntryContent = null;
    }

    private async Task SaveEntryEdit(Entry entry)
    {
        if (editEntryEditor != null)
        {
            EditingEntryContent = await editEntryEditor.GetContent();
        }

        if (string.IsNullOrWhiteSpace(EditingEntryContent))
        {
            await ShowToast("Error: entry content cannot be empty.");
            return;
        }

        try
        {
            entry.Content = EditingEntryContent;
            entry.LastModifiedAt = DateTime.UtcNow;
            await DbContext.SaveChangesAsync();

            EditingEntryId = null;
            EditingEntryContent = null;
            await ShowToast("Entry updated successfully.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating entry {EntryId}", entry.Id);
            await ShowToast("Error updating entry.");
        }
    }
}